# Kryon Binary Format Specification (KRB) v0.4

## Change Log
*   **v0.4**: Introduced `Component Definition Table` section to store reusable component templates separately from the main UI tree. Added `Component Def Count` and `Component Def Offset` to File Header (increasing header size to 48 bytes). Added `FLAG_HAS_COMPONENT_DEFS` to Header Flags. Clarified that `Element Count` now refers only to elements in the instantiated main UI tree. This allows for `.kry` `Define`d components to be included in KRB for runtime instantiation without interfering with the primary UI structure. Version number updated.
*   **v0.3**: Added `Custom Prop Count` (1 byte) to Element Header, increasing header size to 17 bytes. Defined structure for optional `Custom Properties` section following standard properties within Element Blocks. Clarified `ELEM_TYPE_CUSTOM` usage and `PROP_ID_CUSTOM` (0x19) as a data blob. Added documentation notes emphasizing compiler expansion (`.kry`'s `Define`) as the preferred method for component abstraction over direct KRB custom types/properties for portability. Version number updated.
*   **v0.2**: Formalized as pre-release version. Added explicit `Resource Offset` to Header. Clarified Flag interactions, Layout byte source, indexing bases, and Resource Data field. Header size 42 bytes. Renamed from draft v1.1.
*   **v0.1**: Initial draft corresponding to implicit resource offset.

## Kryon Ecosystem Overview

Kryon consists of two distinct formats and typically a compiler:

1.  **Kryon Source Language (.kry)**:
    *   A human-readable, text-based language for defining user interfaces, including features like component definition (`Define`) for abstraction.
    *   Defined in a separate specification (`kry_source_spec_v1.0.md` or similar).
    *   Compiled into the binary format (.krb).

2.  **Kryon Binary Format (.krb)**:
    *   A compact, platform-independent binary representation of the UI.
    *   Generated by compiling `.kry` source files.
    *   Files use the `.krb` extension.
    *   Optimized for parsing and rendering on resource-constrained systems.


3.  **Kryon Compiler (`kryonc`)**:
    *   Translates `.kry` source files into `.krb` binary files.
    *   Expands `.kry` `Define` component usage into standard KRB elements.
    *   Maps standard `.kry` properties to standard KRB properties.
    *   **Crucially, encodes component-specific properties (like `position` from a `TabBar`) declared in `.kry` `Properties` blocks into the KRB `Custom Properties` section for later interpretation.**

**Runtime Expectation:** Runtimes parsing `.krb` files must understand the standard elements and properties defined here. KRB v0.3 introduces an optional **Custom Properties** section within Element Blocks. This allows compilers to embed application-specific key-value data (like `position="bottom"` originating from a custom `.kry` component like `<TabBar>`) directly into the KRB. **Crucially, the interpretation and handling of these Custom Properties is the responsibility of the specific runtime environment.** Standard runtimes might ignore custom properties they don't recognize. Compiler expansion (`Define` in `.kry`) that resolves components entirely into standard elements *without* relying on runtime interpretation of custom properties remains the recommended approach for maximum portability, but this Custom Properties mechanism enables runtime-specific handling when required.

## Design Goals
*   **Universal Compatibility**: Works across diverse computing environments, including 8-bit systems.
*   **Compact Representation**: Minimal memory footprint.
*   **Performance-Oriented**: Fast parsing, efficient rendering.
*   **Feature Complete**: Aims to cover common UI needs.
*   **Extensible**: Allows for custom element types and properties, although standard types are preferred for maximum compatibility and simplicity.
*   **Stack-Friendly**: Suitable for minimal environments.

## File Structure

[File Header]          # Format identification and section offsets
[Element Blocks]       # Starts with App (if present), followed by other elements
[Style Blocks]         # Reusable styles (optional)
[Animation Table]      # Transitions and keyframe animations (optional)
[String Table]         # Text content and identifiers
[Resource Table]       # External resources (optional)

## 1. File Header (48 bytes)

| Offset | Size | Field                | Description                          | Example                                          |
|--------|------|----------------------|--------------------------------------|--------------------------------------------------|
| 0      | 4    | Magic Number         | Format identifier                    | `0x4B 0x52 0x42 0x31` ("KRB1")                   |
| 4      | 2    | Version              | Format version (Minor << 8 \| Major) | `0x00 0x04` (for v0.4)                           |
| 6      | 2    | Flags                | Format capabilities                  | `0x02 0x00` (if only `FLAG_HAS_COMPONENT_DEFS` set from bits 0-7 for example) |
| 8      | 2    | Element Count        | Number of elements in main UI tree   | `0x05 0x00` (5)                                  |
| 10     | 2    | Style Count          | Number of styles                     | `0x02 0x00` (2)                                  |
| 12 | 2| Component Def Count | Number of component definitions    | `0x01 0x00` (1)                              
| 14     | 2    | Animation Count      | Number of animations                 | `0x03 0x00` (3)                                  |
| 16     | 2    | String Count         | Number of strings                    | `0x0A 0x00` (10)                                 |
| 18     | 2    | Resource Count       | Number of resources                  | `0x01 0x00` (1)                                  |
| 20     | 4    | Element Offset       | Byte offset to elements section      | `0x30 0x00 0x00 0x00` (48)                       |
| 24     | 4    | Style Offset         | Byte offset to styles section        | `0xCA 0x00 0x00 0x00` (Offset depends on element data) |
| 28 | 4| Component Def Offset|Byte offset to Component Defs section| `0xDC 0x00 0x00 0x00` (Offset depends on prev sections) |
| 32     | 4    | Animation Offset     | Byte offset to animations section    | `0xFC 0x00 0x00 0x00` (Offset depends on prev sections) |
| 36     | 4    | String Offset        | Byte offset to strings section       | `0x42 0x01 0x00 0x00` (Offset depends on prev sections) |
| 40     | 4    | Resource Offset      | Byte offset to resources section     | `0x8A 0x01 0x00 0x00` (Offset depends on prev sections) |
| 44     | 4    | Total Size           | Total file size in bytes             | `0xB8 0x01 0x00 0x00` (Calculated total)         |

*   **Endianness**: **Little-endian** for all multi-byte values.
*   **Flags**:
    *   Bit 0: `FLAG_HAS_STYLES`
    *   Bit 1: `FLAG_HAS_COMPONENT_DEFS`
    *   Bit 2: `FLAG_HAS_ANIMATIONS`
    *   Bit 3: `FLAG_HAS_RESOURCES`
    *   Bit 4: `FLAG_COMPRESSED` (*Not currently specified*)
    *   Bit 5: `FLAG_FIXED_POINT` (Required if `VAL_TYPE_PERCENTAGE` used)
    *   Bit 6: `FLAG_EXTENDED_COLOR` (4-byte RGBA vs 1-byte palette index)
    *   Bit 7: `FLAG_HAS_APP` (First element is `App`)
    *   Bit 8-15: Reserved
## 2. Element Blocks

Starts at `Element Offset` from the header. Contains `Element Count` blocks.

### Element Header (17 bytes)

| Offset | Size | Field                 | Description                                                | Example             |
|--------|------|-----------------------|------------------------------------------------------------|---------------------|
| 0      | 1    | Type                  | Element type (`ELEM_TYPE_*`)                               | `0x01` (Container)  |
| 1      | 1    | ID                    | String table index (0-based) for ID name, or 0 if no ID    | `0x01` ("main")     |
| 2      | 2    | Position X            | X coordinate or offset                                     | `0x0A 0x00` (10)    |
| 4      | 2    | Position Y            | Y coordinate or offset                                     | `0x0A 0x00` (10)    |
| 6      | 2    | Width                 | Width in pixels/units                                      | `0xC8 0x00` (200)   |
| 8      | 2    | Height                | Height in pixels/units                                     | `0x64 0x00` (100)   |
| 10     | 1    | Layout                | Effective layout flags (See Layout Byte). Compiler sets.   | `0x05` (Col, Center)|
| 11     | 1    | Style ID              | 1-based index into Style Blocks array, or 0 for no style.  | `0x01` (Style #1)   |
| 12     | 1    | Property Count        | Number of *standard* subsequent properties                 | `0x02` (2)          |
| 13     | 1    | Child Count           | Number of subsequent child references                      | `0x03` (3)          |
| 14     | 1    | Event Count           | Number of subsequent event references                      | `0x01` (1)          |
| 15     | 1    | Animation Count       | Number of subsequent animation references                  | `0x00` (0)          |
| **16** | **1**| **Custom Prop Count** | **Number of *custom* key-value properties following standard props.** | **`0x01` (1)**      | 

**Element Types** (`ELEM_TYPE_*`):
*   **Core Elements** (0x00–0x0F): `0x00`:App, `0x01`:Container, `0x02`:Text, `0x03`:Image, `0x04`:Canvas, `0x05`–`0x0F`:Reserved
*   **Interactive Elements** (0x10–0x1F): `0x10`:Button, `0x11`:Input, `0x12`–`0x1F`:Reserved
*   **Structural Elements** (0x20–0x2F): `0x20`:List, `0x21`:Grid, `0x22`:Scrollable, `0x23`–`0x2F`:Reserved
*   **Specialized Elements** (0x30–0xFF): `0x30`:Video, `0x31`–`0xFF`: **Custom**
    *   **Note on Custom Types:** Types `0x31-0xFF` denote application-specific elements requiring full runtime interpretation. The `ID` field (String Table index) may identify the type. **Using standard element types (like `Container`) combined with the Custom Properties section below is often preferred over defining entirely new `ELEM_TYPE_CUSTOM` types for component representation if only specific behaviors (like positioning) need runtime interpretation.** Standard runtimes may ignore unknown custom types.

**Layout Byte**: (*Defines the value in the Element Header's `Layout` field*)
*   Bits 0-1: Direction (`00`:Row, `01`:Column, `10`:RowReverse, `11`:ColumnReverse)
*   Bits 2-3: Alignment (`00`:Start, `01`:Center, `10`:End, `11`:SpaceBetween)
*   Bit 4: Wrap (`0`:NoWrap, `1`:Wrap)
*   Bit 5: Grow (`0`:Fixed, `1`:Grow)
*   Bit 6: Position (`0`:FlowLayout, `1`:AbsolutePosition)
*   Bit 7: Reserved

### Standard Properties

Follow the element header, `Property Count` entries.

| Offset   | Size     | Field       | Description                                          | Example             |
|----------|----------|-------------|------------------------------------------------------|---------------------|
| 0        | 1        | Property ID | Standard Identifier (`PROP_ID_*`)                    | `0x01` (BgColor)    |
| 1        | 1        | Value Type  | Data type (`VAL_TYPE_*`)                             | `0x03` (Color)      |
| 2        | 1        | Size        | Value size in bytes (e.g., 1 or 4 for Color)         | `0x04` (4 bytes)    |
| 3        | Variable | Value       | Property value data according to Type and Size       | `0xFF0000FF` (Red)  |

**Property IDs** (`PROP_ID_*`):

*   `0x01`: BackgroundColor (Value: `VAL_TYPE_COLOR`)
*   `0x02`: ForegroundColor / TextColor (Value: `VAL_TYPE_COLOR`)
*   `0x03`: BorderColor (Value: `VAL_TYPE_COLOR`)
*   `0x04`: BorderWidth (Value: `VAL_TYPE_BYTE`, uint8)
*   `0x05`: BorderRadius / CornerRadius (Value: `VAL_TYPE_BYTE`, uint8)
*   `0x06`: Padding (Value: `VAL_TYPE_EDGEINSETS`, e.g., 4 bytes/shorts)
*   `0x07`: Margin (Value: `VAL_TYPE_EDGEINSETS`, e.g., 4 bytes/shorts)
*   `0x08`: TextContent (Value: `VAL_TYPE_STRING`, string index)
*   `0x09`: FontSize (Value: `VAL_TYPE_SHORT`, uint16)
*   `0x0A`: FontWeight (Value: `VAL_TYPE_ENUM`, e.g., 0=Normal, 1=Bold)
*   `0x0B`: TextAlignment (Value: `VAL_TYPE_ENUM`, e.g., 0=Start, 1=Center, 2=End)
*   `0x0C`: ImageSource (Value: `VAL_TYPE_RESOURCE`, resource index)
*   `0x0D`: Opacity (Value: `VAL_TYPE_PERCENTAGE`, 8.8 fixed point representing 0.0-1.0 scaled to 0-256 range; requires `FLAG_FIXED_POINT`)
*   `0x0E`: ZIndex (Value: `VAL_TYPE_SHORT`, int16)
*   `0x0F`: Visibility (Value: `VAL_TYPE_BYTE`, 0=Hidden, 1=Visible)
*   `0x10`: Gap (Value: `VAL_TYPE_SHORT`, uint16, spacing between flow layout children)
*   `0x11`: MinWidth (Value: `VAL_TYPE_SHORT` for pixels OR `VAL_TYPE_PERCENTAGE` for percentage; runtime must check type. Percentage requires `FLAG_FIXED_POINT`)
*   `0x12`: MinHeight (Value: `VAL_TYPE_SHORT` for pixels OR `VAL_TYPE_PERCENTAGE` for percentage; runtime must check type. Percentage requires `FLAG_FIXED_POINT`)
*   `0x13`: MaxWidth (Often used for `width`. Value: `VAL_TYPE_SHORT` for pixels OR `VAL_TYPE_PERCENTAGE` for percentage; runtime must check type. Percentage requires `FLAG_FIXED_POINT`)
*   `0x14`: MaxHeight (Often used for `height`. Value: `VAL_TYPE_SHORT` for pixels OR `VAL_TYPE_PERCENTAGE` for percentage; runtime must check type. Percentage requires `FLAG_FIXED_POINT`)
*   `0x15`: AspectRatio (Value: `VAL_TYPE_PERCENTAGE`, 8.8 fixed point, e.g., 1.0 = 256; requires `FLAG_FIXED_POINT`)
*   `0x16`: Transform (Value: `VAL_TYPE_STRING`, string index representing transform)
*   `0x17`: Shadow (Value: `VAL_TYPE_STRING`, string index representing shadow)
*   `0x18`: Overflow (Value: `VAL_TYPE_ENUM`, e.g., 0=Visible, 1=Hidden, 2=Scroll)

*   `0x19`: **Custom Data Blob** - Value is arbitrary binary data. `Value Type` should indicate format (e.g., `VAL_TYPE_CUSTOM`), `Size` gives length. The `ID` field in the Element Header (or another standard property) should provide context for runtime interpretation.
*   `0x1A`: **LayoutFlags** - Compiler *uses* this `.kry` property (`layout: ...`) to compute and set the final `Layout` byte in the Element Header. This property ID itself is typically **not** written into the KRB file's property list, as its effect is encoded in the header.
*   **App-Specific** (`0x20`-`0x28`, Only valid on `ELEM_TYPE_APP`):
    *   `0x20`: WindowWidth (Value: `VAL_TYPE_SHORT`, uint16)
    *   `0x21`: WindowHeight (Value: `VAL_TYPE_SHORT`, uint16)
    *   `0x22`: WindowTitle (Value: `VAL_TYPE_STRING`, string index)
    *   `0x23`: Resizable (Value: `VAL_TYPE_BYTE`, 0=False, 1=True)
    *   `0x24`: KeepAspect (Value: `VAL_TYPE_BYTE`, 0=False, 1=True)
    *   `0x25`: ScaleFactor (Value: `VAL_TYPE_PERCENTAGE`, 8.8 fixed point; requires `FLAG_FIXED_POINT`)
    *   `0x26`: Icon (Value: `VAL_TYPE_RESOURCE`, resource index)
    *   `0x27`: Version (Value: `VAL_TYPE_STRING`, string index)
    *   `0x28`: Author (Value: `VAL_TYPE_STRING`, string index)
*   *(IDs `0x29` - `0x2F` reserved)*
*   *(IDs `0x30`+ potentially used for custom properties if not using the dedicated Custom Properties section)*

**Value Types** (`VAL_TYPE_*`):
*   `0x00`: None
*   `0x01`: Byte (1 byte)
*   `0x02`: Short (2 bytes, little-endian)
*   `0x03`: **Color** (Size/Format depends on `FLAG_EXTENDED_COLOR`: 4 bytes RGBA if set, 1 byte palette index if clear)
*   `0x04`: String Index (1 byte, 0-based index into String Table)
*   `0x05`: **Resource Index** (1 byte, 0-based index into Resource Table)
*   `0x06`: **Percentage** (Size is 2 bytes, 8.8 fixed-point, little-endian; `FLAG_FIXED_POINT` must be set if used)
*   `0x07`: Rectangle (e.g., 8 bytes: 4 shorts x,y,w,h)
*   `0x08`: EdgeInsets (e.g., 4 bytes/shorts: top,right,bottom,left)
*   `0x09`: Enum (Typically 1 byte, specific meanings depend on Property ID)
*   `0x0A`: Vector (e.g., 4 bytes: 2 shorts x,y)
*   `0x0B`: Custom (Indicates application-specific interpretation, often used with `PROP_ID_CUSTOM_DATA_BLOB`)
*   Others Reserved

### Custom Properties

Follows the Standard Properties section. Contains `Custom Prop Count` entries. This section provides a structured way to embed key-value data directly in the KRB **for runtime interpretation**.

**Purpose:** Allows custom components defined in `.kry` (e.g., using `Define`) to pass component-specific properties (like `position`, `orientation`, custom data bindings) through the compiler into the `.krb` file. The compiler translates these into key-value pairs here.

**Runtime Responsibility:** The runtime environment is responsible for:
1.  Checking for the presence of custom properties on elements it processes.
2.  Interpreting the meaning of specific keys (e.g., "position", "customBehavior").
3.  Implementing the corresponding layout, rendering, or behavioral logic based on the values found.
    *   *Example:* A runtime might check any `Container` for a `custom_prop[key="position"]`. If found, it applies specific layout logic to that container relative to its siblings based on the property's value ("top", "bottom", etc.).

**Note:** Using this section ties the `.krb` file's full behavior to a runtime capable of interpreting these specific custom property keys. Prefer compiler resolution into standard properties whenever possible for better portability.

Each custom property entry structure:

| Offset   | Size     | Field      | Description                                           | Example                      |
|----------|----------|------------|-------------------------------------------------------|------------------------------|
| 0        | 1        | Key Index  | String table index (0-based) for the property key name | `0x05` ("position")        |
| 1        | 1        | Value Type | Data type (`VAL_TYPE_*`) for the value                | `0x04` (String Index)        |
| 2        | 1        | Value Size | Value size in bytes (e.g., 1 for String Index)        | `0x01` (1 byte)             |
| 3        | Variable | Value      | Property value data according to Type and Size        | `0x08` ("bottom" string index) |

### Events

Follow Custom Properties (if any). Contains `Event Count` entries.

| Offset | Size | Field       | Description                          | Example             |
|--------|------|-------------|--------------------------------------|---------------------|
| 0      | 1    | Event Type  | `EVENT_TYPE_*`                       | `0x01` (Click)      |
| 1      | 1    | Callback ID | String table index (0-based) for function name | `0x03` ("handleClick") |

**Event Types** (`EVENT_TYPE_*`): `0x01`:Click, `0x02`:Press, `0x03`:Release, `0x04`:LongPress, `0x05`:Hover, `0x06`:Focus, `0x07`:Blur, `0x08`:Change, `0x09`:Submit, `0x0A`:Custom (Runtime defined). Others Reserved.

### Animation References

Follow Events. Contains `Animation Count` entries.

| Offset | Size | Field           | Description                             | Example        |
|--------|------|-----------------|-----------------------------------------|----------------|
| 0      | 1    | Animation Index | 0-based index into Animation Table      | `0x00` (Anim #0) |
| 1      | 1    | Trigger         | `TRIGGER_TYPE_*` that starts animation | `0x01` (Click)   |

**Trigger Types** (`TRIGGER_TYPE_*`): `0x00`:Auto, `0x01`:Click, `0x02`:Hover, `0x03`:Focus, `0x04`:Load, `0x05`:Custom (Runtime defined). Others Reserved.

### Child References

Follow Animation References. Contains `Child Count` entries.

| Offset | Size | Field        | Description                                                 | Example        |
|--------|------|--------------|-------------------------------------------------------------|----------------|
| 0      | 2    | Child Offset | Byte offset *from start of this parent's header* to child header | `0x5A 0x00` (90) |

## 3. Style Blocks

Starts at `Style Offset`. Contains `Style Count` blocks. Defines reusable sets of *standard* properties.

### Style Header

| Offset   | Size     | Field          | Description                                   | Example           |
|----------|----------|----------------|-----------------------------------------------|-------------------|
| 0        | 1        | ID             | Style identifier (**1-based**)                | `0x01` (Style #1) |
| 1        | 1        | Name Index     | String table index (0-based) for style name   | `0x02` ("btn")    |
| 2        | 1        | Property Count | Number of standard properties in this style   | `0x04` (4)        |
| 3        | Variable | Properties     | Standard Property definitions (ID, Type, Size, Value) |                   |



## 4. Component Definition Table

Starts at `Component Def Offset` from the File Header. Contains `Component Def Count` entries. This section stores reusable component templates defined in `.kry` source files (e.g., via `Define ComponentName { ... }`). Runtimes can use these definitions to instantiate components dynamically.

**Each Component Definition Entry:**

| Offset Relative to Entry Start | Size     | Field                   | Description                                                                                                                                                                                                |
|--------------------------------|----------|-------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0                              | 1        | `Name Index`            | 0-based index into the String Table for the component's `Define`d name (e.g., "HabitTabBar"). This is the primary key for looking up the definition.                                                        |
| 1                              | 1        | `Property Def Count`    | Number of subsequent property definitions that this component accepts (from its `.kry` `Properties { ... }` block).                                                                                          |
| 2                              | Variable | `Property Definitions`  | An array of `Property Def Count` entries, each describing an acceptable property. (See "Property Definition Structure" below).                                                                               |
| Next                           | Variable | `Root Element Template` | A complete KRB Element Block defining the root element of this component's template structure. This block follows the standard "Element Header" and "Standard Properties" structure. **It should NOT contain "Custom Properties" or "Events" that are specific to an instance.** Child references within this template are to other elements *also defined within this template block*, and their offsets are relative to the start of *this template's root element header*. |

**Property Definition Structure (within each Component Definition Entry):**

This structure describes properties declared in a component's `Properties { ... }` block in the `.kry` source.

| Offset Relative to Prop Def Start | Size     | Field             | Description                                                                                                                                                              |
|-----------------------------------|----------|-------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0                                 | 1        | `Name Index`      | 0-based index into the String Table for the property's name (e.g., "orientation", "bar_style").                                                                        |
| 1                                 | 1        | `Value Type Hint` | A `VAL_TYPE_*` enum value indicating the expected data type for this property, as hinted in the `.kry` source (e.g., `VAL_TYPE_STRING`, `VAL_TYPE_SHORT`, `VAL_TYPE_COLOR`). |
| 2                                 | 1        | `Default Value Size`| Size in bytes of the subsequent `Default Value Data`. If 0, no default value is provided for this property.                                                              |
| 3                                 | Variable | `Default Value Data`| The actual data for the default value, if `Default Value Size` > 0. The format of this data depends on the `Value Type Hint` (e.g., a 1-byte string index, 4-byte RGBA color). |

**Notes on `Root Element Template`:**
*   The `Root Element Template` is essentially a serialized `Element Block` as defined in Section 2 of the KRB spec (Element Header, Standard Properties, Child References).
*   **Crucially, offsets for `Child References` within a template are relative to the start of that template's own root element header.** This makes the template self-contained and relocatable.
*   The template typically defines the *structure* and *default standard properties*. Instance-specific data (like `id`, specific event handlers, or values for custom properties like `position="bottom"`) are applied by the runtime or resolver when an instance of this component is created.
*   The `ID` field in the template's root element header (if set, e.g., via a KRY `Define Component { RootElement { id: "template_root_id"; ... } }`) typically serves as an internal identifier for the template's structure itself. **When a component instance is created (e.g., from a KRY `<Component id="instance_id">` usage), the `id` provided in the instance usage will always override any `ID` set within the template's root element.** The template's root ID is generally not used for instance lookup.
*   The `Property Count` in the template's root element header refers to its *standard* properties.
*   The `Custom Prop Count` in the template's root element header should typically be 0.
*   The `Event Count` in the template's root element header should typically be 0.

---

## 5. Animation Table

Starts at `Animation Offset`. Contains `Animation Count` entries. Indices are **0-based**. Animations operate on *standard* properties.

### Transition Animation

| Offset   | Size     | Field           | Description                         | Example          |
|----------|----------|-----------------|-------------------------------------|------------------|
| 0        | 1        | Type            | `0x01` (Transition)                 |                  |
| 1        | 1        | ID              | Animation index (**0-based**)       | `0x00`           |
| 2        | 2        | Duration        | Milliseconds or Frames (little-endian)| `0xE8 0x03` (1000ms)|
| 4        | 1        | Timing Function | `TIMING_*` (Linear, EaseInOut...)   | `0x01`           |
| 5        | 1        | Property Count  | Number of standard properties to animate | `0x01`           |
| 6        | Variable | Properties      | Animated props (ID, Type, Size, StartValue, EndValue) |       |

### Keyframe Animation

| Offset   | Size     | Field          | Description                             | Example         |
|----------|----------|----------------|-----------------------------------------|-----------------|
| 0        | 1        | Type           | `0x02` (Keyframe)                       |                 |
| 1        | 1        | ID             | Animation index (**0-based**)           | `0x01`          |
| 2        | 2        | Duration       | Milliseconds or Frames (little-endian)  | `0xD0 0x07` (2000ms)|
| 4        | 1        | Repeat Mode    | `REPEAT_*` (None, Loop...)              | `0x01`          |
| 5        | 1        | Keyframe Count | Number of keyframes                     | `0x03`          |
| 6        | Variable | Keyframes      | Keyframe definitions (TimeOffset, PropID, Type, Size, Value) | |

## 6. String Table

Starts at `String Offset`. Contains `String Count` strings. Indices are **0-based**. Index 0 may represent an empty/null string.

### String Table Header

| Offset   | Size     | Field        | Description                       | Example        |
|----------|----------|--------------|-----------------------------------|----------------|
| 0        | 2        | String Count | Number of strings (little-endian) | `0x0A 0x00` (10) |
| 2        | Variable | Strings      | Series of length-prefixed UTF-8 strings |                |

For each string: `[Length (1 byte)] [UTF-8 Bytes (Variable)]`

## 7. Resource Table

Starts at `Resource Offset`. Contains `Resource Count` entries. Indices are **0-based**.

### Resource Table Header

| Offset   | Size     | Field          | Description                       | Example        |
|----------|----------|----------------|-----------------------------------|----------------|
| 0        | 2        | Resource Count | Number of resources (little-endian)| `0x01 0x00` (1) |
| 2        | Variable | Resources      | Series of resource entries        |                |

For each resource entry:

| Offset   | Size     | Field      | Description                                  | Example                |
|----------|----------|------------|----------------------------------------------|------------------------|
| 0        | 1        | Type       | `RES_TYPE_*` (Image, Font...)                | `0x01` (Image)         |
| 1        | 1        | Name Index | String table index (0-based) for name/path   | `0x04` ("bg.png")      |
| 2        | 1        | Format     | `RES_FORMAT_*` (External, Inline)            | `0x00` (External)      |
| 3        | Variable | Data       | Format-specific data (Path index or Size+Bytes)| (See below)            |

**Resource Types** (`RES_TYPE_*`): `0x01`:Image, `0x02`:Font, `0x03`:Sound, `0x04`:Video, `0x05`:Custom. Others Reserved.

**Resource Formats** (`RES_FORMAT_*`):
*   `0x00` (External): `Data` is **1 byte**: the String Table index (0-based) of the resource path/URL. Total entry size: 4 bytes.
*   `0x01` (Inline): `Data` is **`[Size (2 bytes, little-endian)] [Raw Bytes (Variable)]`**. Total entry size: 3 + Size + Raw Bytes length.

## Stack-Based Considerations & Optimizations

*   **Custom Property Interpretation Overhead:** Relying heavily on runtime interpretation of Custom Properties adds complexity and potential performance cost to the runtime compared to handling pre-resolved standard properties. Use judiciously for behaviors the compiler cannot fully resolve.
*   **Minimize Custom Data:** Relying heavily on `ELEM_TYPE_CUSTOM` or the Custom Properties section increases runtime complexity and KRB file size. Prefer compiler abstractions (`Define` in `.kry`) that resolve to standard KRB elements and properties whenever possible.
*   Use 8-bit indices where feasible (String Table, Resource Table indices if counts are low).
*   Simplify numeric values (palette colors via `FLAG_EXTENDED_COLOR=0`, frame-based time).
*   Prefer fixed element sizes where appropriate.
*   Precompute layouts during compilation (Compiler sets `Layout` byte).
*   Consider String Table compression (future extension via `FLAG_COMPRESSED`).
*   Simplify or omit animations if not essential.
*   Use memory-efficient stream parsing in runtimes.

## Conclusion

Kryon KRB v0.4 defines a specification for a universal, compact binary UI format. It adds an optional **Custom Properties** mechanism allowing component-specific data defined in `.kry` to be passed into the binary file. **The interpretation and handling of this custom data is explicitly the responsibility of the target runtime environment.** While compiler expansion into purely standard elements/properties remains ideal for portability, this feature enables richer runtime-specific behaviors when needed.